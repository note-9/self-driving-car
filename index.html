<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Self-Driving Car Simulation (Vanilla JS)</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{display:flex;gap:12px;padding:12px}
    canvas{background:#222;border-radius:6px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    .ui{width:300px}
    h1{font-size:16px;margin:0 0 8px}
    button,input{width:100%;padding:8px;margin:6px 0;border-radius:6px;border:1px solid #444;background:#0f0f0f;color:#ddd}
    label{font-size:13px;display:block;margin-top:8px}
    .small{font-size:12px;color:#9aa}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="1000" height="640"></canvas>
    <div class="ui">
      <h1>Self-Driving Car — Vanilla JS</h1>
      <div class="small">Autonomous car uses simple ray sensors and a steering rule. No libraries.</div>
      <label>Simulation</label>
      <button id="start">Start / Resume</button>
      <button id="pause">Pause</button>
      <button id="reset">Reset</button>
      <label>Debug</label>
      <input type="checkbox" id="debug" checked> Show sensors & info
      <label>Speed</label>
      <input id="speedRange" type="range" min="0.25" max="3" step="0.25" value="1">
      <div class="small">Tip: Drag speed to run faster.</div>
      <label>Controls</label>
      <div class="small">Simulation is autonomous. Use buttons to control playback. Press <kbd>R</kbd> to randomly mutate brain.</div>
      <label>Brain</label>
      <button id="mutate">Mutate weights</button>
      <button id="save">Download brain</button>
      <button id="load">Load brain (paste JSON)</button>
      <pre id="info" style="white-space:pre-wrap;background:#0b0b0b;padding:8px;border-radius:6px;height:220px;overflow:auto;margin-top:8px;color:#cfc">Ready.</pre>
    </div>
  </div>

<script>
(() => {
  // --- Utilities ---
  const $ = (id)=>document.getElementById(id);
  const canvas = $('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // --- Map (walls as line segments) ---
  // We'll build a simple closed track (outer box + inner obstacles)
  const walls = [];
  function addWall(x1,y1,x2,y2){ walls.push({x1,y1,x2,y2}); }

  function buildMap(){
    walls.length = 0;
    // Outer border
    addWall(20,20,W-20,20);
    addWall(W-20,20,W-20,H-20);
    addWall(W-20,H-20,20,H-20);
    addWall(20,H-20,20,20);
    // Internal walls / obstacles to form a simple winding track
    addWall(200,20,200,420);
    addWall(200,420,800,420);
    addWall(800,420,800,100);
    addWall(500,100,800,100);
    addWall(400,220,700,220);
    addWall(100,150,350,150);
    addWall(350,150,350,350);
    addWall(350,350,150,350);
    // a few small obstacles
    addWall(600,480,750,480);
    addWall(600,480,600,560);
  }

  // --- Ray / geometry helpers ---
  function intersectRaySegment(rx,ry,dx,dy,x1,y1,x2,y2){
    // parametric ray R = (rx,ry) + t*(dx,dy), t>=0
    // segment S = (x1,y1)+u*(x2-x1,y2-y1), u in [0,1]
    const rpx = dx, rpy = dy;
    const sx = x2 - x1, sy = y2 - y1;
    const denom = rpx*sy - rpy*sx;
    if (Math.abs(denom) < 1e-6) return null; // parallel
    const t = ((x1 - rx)*sy - (y1 - ry)*sx) / denom;
    const u = ((x1 - rx)*rpy - (y1 - ry)*rpx) / denom;
    if (t >= 0 && u >= 0 && u <= 1) {
      return {x: rx + rpx*t, y: ry + rpy*t, dist: Math.hypot(rpx*t, rpy*t)};
    }
    return null;
  }

  // --- Car object ---
  class Car {
    constructor(x,y,angle){
      this.x = x; this.y = y; this.angle = angle; // radians
      this.vel = 0; this.maxSpeed = 3.4; this.acc = 0.08;
      this.width = 18; this.length = 28;
      // sensors: angles relative to car heading
      this.sensorAngles = [-Math.PI*0.4, -Math.PI*0.2, 0, Math.PI*0.2, Math.PI*0.4];
      this.sensorLength = 160;
      // brain: simple weights for sensors to compute steering
      // one weight per sensor; steering = sum(weights * (1 - distNorm))
      this.brain = {weights: this.sensorAngles.map(()=> (Math.random()*2-1))};
      // motor control
      this.steering = 0; // target steering (-1..1)
      this.turnSpeed = 0.035; // how fast it can turn
      this.friction = 0.01;
      this.dead = false;
    }

    sense(walls){
      const readings = [];
      for(let i=0;i<this.sensorAngles.length;i++){
        const a = this.angle + this.sensorAngles[i];
        const dx = Math.cos(a), dy = Math.sin(a);
        let closest = null;
        for(const s of walls){
          const hit = intersectRaySegment(this.x,this.y,dx,dy,s.x1,s.y1,s.x2,s.y2);
          if(hit && hit.dist <= this.sensorLength){
            if(!closest || hit.dist < closest.dist) closest = hit;
          }
        }
        if(closest){
          readings.push(closest.dist);
        } else readings.push(null);
      }
      return readings;
    }

    update(walls, dt){
      if(this.dead) return;
      // accelerate
      this.vel += this.acc;
      if(this.vel > this.maxSpeed) this.vel = this.maxSpeed;
      // sense environment
      const reads = this.sense(walls);
      // compute steering from brain
      // normalize distances: if null (no hit) treat as sensorLength
      const norms = reads.map(d => (d === null ? this.sensorLength : d)/this.sensorLength);
      // steering = weighted sum where closer obstacles produce strong signal
      let steerSignal = 0;
      for(let i=0;i<this.brain.weights.length;i++){
        // value = (1 - norm) so closer -> higher
        steerSignal += this.brain.weights[i] * (1 - norms[i]);
      }
      // clamp
      if(steerSignal > 1) steerSignal = 1;
      if(steerSignal < -1) steerSignal = -1;
      // smooth steering (simple interpolation)
      this.steering += (steerSignal - this.steering) * 0.2;
      // update angle
      this.angle += this.steering * this.turnSpeed * (this.vel/this.maxSpeed) * (dt*60);
      // move
      this.x += Math.cos(this.angle) * this.vel * dt * 60;
      this.y += Math.sin(this.angle) * this.vel * dt * 60;
      // friction / gradual slow
      this.vel *= (1 - this.friction);
      // collision check: simple polygon/segment collision by checking car corners against walls
      const corners = this.getCorners();
      for(const s of walls){
        for(const p of corners){
          // distance from point to segment
          const d = pointSegmentDist(p.x,p.y,s.x1,s.y1,s.x2,s.y2);
          if(d < 3){ // collision threshold
            this.dead = true; this.vel = 0; return;
          }
        }
      }
    }

    getCorners(){
      const hw = this.width/2, hl = this.length/2;
      // car rectangle centered at (x,y) rotated by angle
      const pts = [
        {x: -hl, y: -hw},
        {x: hl, y: -hw},
        {x: hl, y: hw},
        {x: -hl, y: hw}
      ];
      return pts.map(p => ({x: this.x + p.x*Math.cos(this.angle) - p.y*Math.sin(this.angle), y: this.y + p.x*Math.sin(this.angle) + p.y*Math.cos(this.angle)}));
    }

    draw(ctx, debug=false){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.rotate(this.angle);
      // body
      ctx.fillStyle = this.dead ? '#940000' : '#34c';
      roundRect(ctx,-this.length/2,-this.width/2,this.length,this.width,4);
      ctx.fill();
      // windshield line
      ctx.strokeStyle = '#cfe'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,-this.width/2); ctx.lineTo(0,this.width/2); ctx.stroke();
      ctx.restore();
      if(debug) this.drawSensors(ctx);
    }

    drawSensors(ctx){
      const reads = this.sense(walls);
      for(let i=0;i<this.sensorAngles.length;i++){
        const a = this.angle + this.sensorAngles[i];
        const dx = Math.cos(a), dy = Math.sin(a);
        const d = reads[i]===null?this.sensorLength:reads[i];
        ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x + dx*d, this.y + dy*d);
        ctx.strokeStyle = (reads[i]===null) ? 'rgba(200,200,200,0.15)' : 'rgba(255,200,100,0.9)';
        ctx.lineWidth = 2; ctx.stroke();
      }
    }
  }

  // --- helpers ---
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function pointSegmentDist(px,py,x1,y1,x2,y2){
    const vx = x2-x1, vy = y2-y1; const wx = px-x1, wy = py-y1;
    const c1 = vx*wx + vy*wy;
    if(c1 <= 0) return Math.hypot(px-x1,py-y1);
    const c2 = vx*vx + vy*vy;
    if(c2 <= c1) return Math.hypot(px-x2,py-y2);
    const b = c1 / c2; const bx = x1 + b*vx, by = y1 + b*vy; return Math.hypot(px-bx,py-by);
  }

  // --- Simulation state ---
  let car = null;
  let running = true;
  let last = performance.now();
  let debug = true;
  let speedMultiplier = 1;

  function resetSim(){
    buildMap();
    car = new Car(60, 80, 0.0);
    last = performance.now();
    info("Reset simulation — new random brain. Press 'Mutate' to change weights.");
  }

  function mutateBrain(){
    for(let i=0;i<car.brain.weights.length;i++){
      // small gaussian-ish mutation
      car.brain.weights[i] += (Math.random()*2-1)*0.4;
      // clamp
      if(car.brain.weights[i] > 3) car.brain.weights[i]=3;
      if(car.brain.weights[i] < -3) car.brain.weights[i]=-3;
    }
    info('Mutated brain weights: ' + car.brain.weights.map(w=>w.toFixed(2)).join(', '));
  }

  function info(txt){ $('info').textContent = txt; }

  // --- Draw map ---
  function drawMap(ctx){
    ctx.save();
    ctx.lineWidth = 3; ctx.strokeStyle = '#555';
    for(const s of walls){ ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke(); }
    // dashed centre-line (optional)
    ctx.restore();
  }

  // --- Main loop ---
  function loop(now){
    if(!running){ last = now; requestAnimationFrame(loop); return; }
    const dt = (now - last) / 1000 * speedMultiplier;
    last = now;
    car.update(walls, dt);
    // draw
    ctx.clearRect(0,0,W,H);
    drawMap(ctx);
    car.draw(ctx, debug);
    // HUD
    ctx.fillStyle = '#ddd'; ctx.font = '12px monospace';
    ctx.fillText('Speed: ' + car.vel.toFixed(2), 12, H-40);
    ctx.fillText('Steering: ' + car.steering.toFixed(2), 12, H-24);
    ctx.fillText('Weights: ' + car.brain.weights.map(w=>w.toFixed(2)).join(', '), 12, H-8);

    requestAnimationFrame(loop);
  }

  // --- UI hookups ---
  $('start').addEventListener('click', ()=>{ running=true; info('Running'); });
  $('pause').addEventListener('click', ()=>{ running=false; info('Paused'); });
  $('reset').addEventListener('click', ()=>{ resetSim(); });
  $('debug').addEventListener('change', (e)=>{ debug = e.target.checked; });
  $('mutate').addEventListener('click', ()=>{ mutateBrain(); });
  $('speedRange').addEventListener('input', (e)=>{ speedMultiplier = parseFloat(e.target.value); });

  $('save').addEventListener('click', ()=>{
    const data = JSON.stringify(car.brain);
    const blob = new Blob([data],{type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'brain.json'; a.click(); URL.revokeObjectURL(url);
  });
  $('load').addEventListener('click', ()=>{
    const txt = prompt('Paste brain JSON here');
    try{
      const b = JSON.parse(txt);
      if(b.weights && b.weights.length === car.brain.weights.length){ car.brain = b; info('Loaded brain.'); }
      else alert('Invalid brain');
    }catch(e){ alert('Invalid JSON'); }
  });

  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase() === 'r'){ mutateBrain(); }
    if(e.key.toLowerCase() === 'p'){ running = !running; info(running?'Running':'Paused'); }
  });

  // init
  resetSim(); requestAnimationFrame(loop);

})();
</script>
</body>
</html>

